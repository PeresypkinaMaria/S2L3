//работа с векторами и операции над ними
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include "stdafx.h"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include "baggage.h"
#include "Owner.h"
#include "HelpUtils.h"
#include "MyDate.h"

using namespace std;


template <class Type>
class Task {
private:
	vector<Type> vect; //контейнер

	// сортировка по заданному критерию 
	void ShellSort(_int32 n, _int32 typ, _int32(*Compare)(Type, Type, _int32))
	{
		_int32 i, j, step;
		Type tmp;
		for (step = n / 2; step > 0; step /= 2)
			for (i = step; i < n; i++)
			{
				tmp = vect[i];
				for (j = i; j >= step; j -= step)
				{
					if ((Compare(tmp, vect[j - step], typ) == -1))
						vect[j] = vect[j - step];
					else
						break;
				}
				vect[j] = tmp;
			}

	}
	// бинарный поиск
	_int32 BinarySearchElement(_int32 left, _int32 right, _int32 typesearch, Type d, _int32(*Compare)(Type, Type, _int32))
	{
		_int32 midd = 0;
		while (1)
		{
			midd = (left + right) / 2;

			if (Compare(d, vect[midd], typesearch) == -1)// если искомое больше значения в ячейке
				right = midd - 1;				// смещаем правую границу поиска
			else if (Compare(d, vect[midd], typesearch) == 1)  // если искомое меньше значения в ячейке
				left = midd + 1;					// смещаем левую границу поиска
			else                       // иначе (значения равны)
				return midd;           // функция возвращает индекс ячейки

			if (left > right)          // если границы сомкнулись 
				return -1;
		}
	}
public:
	//свойства доступа
	vector<Type> GetVect()
	{
		return vect;
	}

	vector<Type> SetVect(vector<Type> value)
	{
		return vect = value;
	}

	// удаление элемента
	void Remove(_int32 numb)
	{
		if (numb != 0)
			vect.erase(vect.begin() + numb - 1);
	}

	// добавление элемента
	void Add(Type &elem)
	{
		vect.push_back(elem);
	}

	//размер вектора
	_int32 size()
	{
		return vect.size();
	}

	// проверка на пустоту
	bool Is_empty()
	{
		return (vect.size() == 0);
	}

	// вывод в файл
	// void(*f) (Type) - указатель на функцию, которая записывает одну структуру в файл  
	void OutputFile(vector<Type> items, string(*f)(Type, int))
	{
		string newfname = InputFileName();
		ofstream fout(newfname);
		if (fout)
		{
			vector<Type>::const_iterator pos;
			int count = 1;
			for (pos = items.begin(); pos != items.end(); ++pos)
			{
				fout << f(*pos, count) << ' ';
				count++;
			}
			cout << endl << "Файл заполнен!" << endl;
			fout.close();
		}
		else
		{
			cout << "Файл не заполнен!" << endl;
		}
	}

	//Вывод на экран, f - функция, которая выводит одну структуру на экран  
	void OutputScreenBag(vector<baggage> items, void(*f) (baggage))
	{
		vector<baggage>::const_iterator pos;
		_int32 count = 1;
		for (pos = items.begin(); pos != items.end(); ++pos)
		{
			cout << setw(1) << "|" << setw(6) << left << count;
			f(*pos);
			++count;
			cout << endl;
		}
		if (items.empty())
			cout << "Вектор пуст" << endl;
	}

	// вывод на экран
	// void(*f) (Type) - указатель на функцию, которая считывает одну структуру на экран  
	void OutputScreenOw(vector<Owner> items, void(*f) (Owner))
	{
		vector<Owner>::const_iterator pos;
		_int32 count = 1;
		for (pos = items.begin(); pos != items.end(); ++pos)
		{
			cout << setw(1) << "|" << setw(6) << left << count;
			f(*pos);
			++count;
			cout << endl;
		}
		if (items.empty())
			cout << "Вектор пуст!" << endl;
	}

	// ввод из файла
	// Type(*f)(ifstream&) - указатель на функцию, которая считывает одну структуру из файла 
	bool ReadFromFile(Type(*f)(ifstream&))
	{
		string newfname = InputFileName();
		ifstream input;

		input.open(newfname);

		if (!input)
		{
			cout << "Не удалось открыть файл" << endl;
			return false;
		}
		else
		{
			while (!input.eof())
			{
				vect.push_back(f(input));
			}
			vect.erase(vect.begin() + vect.size() - 1);

			input.close();
			return true;
		}
	}

	// ввод с экрана
	//Type(*f)() - указатель на функцию, которая вводит одну структуру с консоли
	void ReadFromScreen(Type(*f)())
	{
		int n;
		Type elem;
		do
		{
			vect.push_back(f());
			n = InputNumber(0, 1, "Вы хотите добавить элемент? (1 - да, 0 - нет)\nВаш выбор: ");
		} while (n != 0);
	}

	// линейный поиск
	// bool(*Equal)(Type, Type, int) - указатель на функцию, которая проверяет равенство искомого эл-та с текущим по typesearch
	vector<Type> LinearySearch(Type search_elem, bool(*Equal)(Type, Type, _int32), _int32 typesearch)
	{
		vector<Type> NewVect;
		for (auto iter = vect.begin(); iter != vect.end(); iter++)
		{
			if (Equal(search_elem, *iter, typesearch))
				NewVect.push_back(*iter);

		}

		return NewVect;
	}
};